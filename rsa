

import java.math.BigInteger;
import java.util.Scanner;
import java.util.Random;
public class RSA {
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {
        try {
            // Input two prime numbers
            System.out.print("Enter a prime number (p): ");
            BigInteger p = sc.nextBigInteger();

            System.out.print("Enter another prime number (q): ");
            BigInteger q = sc.nextBigInteger();

            // Compute n = p * q
            BigInteger n = p.multiply(q);

            // Compute phi = (p-1)(q-1)
            BigInteger phi = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));

            // Generate public key exponent e
            BigInteger e = generateE(phi);

            // Generate private key exponent d (modular inverse of e mod phi)
            BigInteger d = e.modInverse(phi);

            System.out.println("Public key (e, n): " + e + ", " + n);
            System.out.println("Private key (d, n): " + d + ", " + n);

            sc.nextLine(); // Consume leftover newline

            // Input the message to encrypt
            System.out.print("Enter the message to encrypt (as a number): ");
            BigInteger message = new BigInteger(sc.nextLine());

            if (message.compareTo(n) >= 0) {
                System.out.println("Message must be less than n. Please enter a smaller number.");
                return;
            }

            // Encrypt: c = m^e mod n
            BigInteger encrypted = message.modPow(e, n);
            System.out.println("Encrypted message: " + encrypted);

            // Decrypt: m = c^d mod n
            BigInteger decrypted = encrypted.modPow(d, n);
            System.out.println("Decrypted message: " + decrypted);
        } catch (Exception ex) {
            System.out.println("Error: " + ex.getMessage());
        }
    }

    // Generate e such that 1 < e < phi and gcd(e, phi) = 1
    public static BigInteger generateE(BigInteger phi) {
        Random rand = new Random();
        BigInteger e;

        do {
            e = new BigInteger(phi.bitLength(), rand);
            // Ensure 1 < e < phi
        } while (e.compareTo(BigInteger.ONE) <= 0 || e.compareTo(phi) >= 0 || !phi.gcd(e).equals(BigInteger.ONE));
        return e;
    }
}
