import random
from math import gcd

# Function to generate e such that 1 < e < phi and gcd(e, phi) = 1
def generate_e(phi):
    while True:
        e = random.randrange(2, phi)
        if gcd(e, phi) == 1:
            return e

# Function to find modular inverse of e under mod phi
def mod_inverse(e, phi):
    # Extended Euclidean Algorithm
    def egcd(a, b):
        if a == 0:
            return b, 0, 1
        g, y, x = egcd(b % a, a)
        return g, x - (b // a) * y, y
    g, x, y = egcd(e, phi)
    if g != 1:
        raise Exception('No modular inverse')
    else:
        return x % phi

# Main
p = int(input("Enter a prime number (p): "))
q = int(input("Enter another prime number (q): "))

# n = p * q
n = p * q

# phi = (p-1)*(q-1)
phi = (p - 1) * (q - 1)

# Generate e and d
e = generate_e(phi)
d = mod_inverse(e, phi)

print(f"\nPublic key (e, n): ({e}, {n})")
print(f"Private key (d, n): ({d}, {n})")

# Input message
message = int(input("\nEnter the message to encrypt (as a number): "))

if message >= n:
    print("Message must be less than n. Please enter a smaller number.")
    exit()

# Encrypt: c = m^e mod n
encrypted = pow(message, e, n)
print("Encrypted message:", encrypted)

# Decrypt: m = c^d mod n
decrypted = pow(encrypted, d, n)
print("Decrypted message:", decrypted)
